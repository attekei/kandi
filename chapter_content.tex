% --------------------------------------------------------------------
% Cheatsheet:
% \verb!lazy val!   -- esim. lyhyisiin koodinpätkiin
% \begin{verbatim}  -- esim. pitkiin koodinpätkiin
% `` tekstiä ''     -- lainausmerkit
% \textbf{huom!}    -- boldaus
% \begin{quotation}
% \noindent \it     -- quoten lisäys
% \ldots            -- kolme pistettä
% footnote{juh}     -- alaviite
% \citet, \citep
% \citet[s.234]{}   -- viitteet, http://merkel.zoneo.net/Latex/natbib.php
% \begin{sloppypar} -- ahdas teksti
% \clearpage        -- onkkelmien korjaamiseen lukujen kanssa
% --                -- yhdysviiva
% \enumerate
% \itemize          -- listat
% \begin[htb]{figure}
% \begin[htb]{table} - Kuva ja taulukko, (h)ere, (t)op, (b)ottom
% \begin{equation}  -- kaava
% \label{eq:kaava1} -- laabeli
%!TEX root = main.tex

\section{Johdanto}

% Määriteltäviä käsitteitä:
% Non-Strict Semantics
% Jotain muuta

% 1. ja 2. kirjoitetaan lopulliseen muotoonsa sitten, kun muut osat ovat jo hyvällä mallilla!

% 1. Aloitan tarinan todellisen elämän esimerkillä, jossa on tullut vastaan aito tarve sille, että koodia ei evaluoida tiukasti "rivi kerrallaan". Siisteintä (ja emotionaalisesti tehokkainta) olisi saada oikein kouriintuntuva esimerkki tilanteesta, jossa ollaan joduttu ongelmiin, kun laiskaa evaluointia ei ole aluksi käytetty. Esimerkillä pyrin herättämään lukijan mielenkiinnon, ja nivomaan aiheen välittömästi konkretiaan ennen siihen syventymistä.

Laiska evaluointi on 1970-luvulta juontuva ohjelmoinnin konsepti, jonka ytimessä on turhan ja liian aikaisen laskennan välttäminen ohjelmakoodia suorittaessa. Eli jos esimerkiksi listan alkiota ei koskaan tarvita, niin sen arvoakaan ei ole syytä laskea. Vastaavasti jos arvoa tarvitaankin, sitä ei lasketa listaa muodostettaessa, vaan vasta sitten kuin sitä on tarve käyttää.

Laiska evaluointi on nimityksenä vakiintunut, mutta ``laiskuuden'' osalta hieman harhaanjohtava. Paremmin konseptia kuvaa sen englanninkielinen synonyymi \textit{call-by-need evaluation}, joka korostaa sitä, että laskentaa tehdään vasta kun tietoa tarvitaan. Toinen tulkinta on, että laskentaa viivytetään niin kauan, kunnes arvo on pakko laskea.

% 2. Kerron, kuinka 2000-luvulla on näkynyt paljon kehitystä, jossa ajatusta siitä, että lausekkeita ei ole aina pakko evaluoida välittömästi kun ne koodissa määritellään, on sovellettu laajemmalle. Esimerkiksi uudet ohjelmointikielet kuten Scala tukevat sitä, ja monet laiskan evaluoinnin ajatusta hyödyntävät kirjastot ovat nähneet päivänvalon esimerkiksi JavaScriptissä. Jos tuntuu luontevalta, niin samassa yhteydessä voi antaa lukijalle alustavan intuition laiskasta evaluoinnista vertauskuvia hyödyntäen (korostaen että kyseessä analogia, ei eksakti käsitemäärittely).

Laiskan evaluoinnin tekee aiheena kiinnostavaksi se, että sitä hyödynnetään kasvavissa määrin niin ohjelmointikielien suunnittelussa kuin yksittäisissa sovelluskirjastoissa. Esimerkiksi uudehkot ohjelmointikielet, kuten Scala ja Clojure, tarjoavat erityisiä syntaktisia rakenteita sitä varten. Toisaalta myös monet suositut apukirjastot, esimerkiksi JavaScript-kielen Immutable.js, Lazy.js ja Bacon.js, hyödyntävät sen periaatteita.

Laiskaa evaluointia ei ole yhtä tapaa tehdä ``oikein'', vaan käyttökohteiden ja toteutustapojen diversiteetti on suuri. Myös tavoiteltavat hyödyt ovat erilaisia. Verrataan esimerkiksi ohjelmointikielen ja apukirjaston laatijoiden tavoitteita: ohjelmointikielen laatija voi käyttää laiskaa evaluointia kielen ilmaisuvoiman kasvattamiseen, kun taas apukirjaston laatija voi päästä sen avulla kilpailevia kirjastoja parempaan suorituskykyyn.

Ymmärrän tässä työssä laiskan evaluoinnin laajasti, ja pyrin luomaan kokonaiskuvaa konseptin käyttökohteista ja toteutustavoista.  Seuraavaksi määrittelen tarkemmin, mitä tarkoitan laiskalla evaluoinnilla, ja mitä muita käsitteitä konseptiin tiiviisti liittyy. Sen jälkeen esittelen tutkimuskysymykset, joihin työni pyrkii vastaamaan.

% 3. Määrittelen sitä tietotekniikan kontekstia, jossa nyt liikutaan, ja määrittelen keskeisiä käsitteitä "up-to-bottom". Ensiksi kerron mistä koodin evaluoinnissa on kyse, millaisia erilaisia evaluointitapoja on olemassa (vielä kuitenkaan vertailematta niiden vahvuuksia/heikkouksia). Lopulta tarkennan laiskaan evaluointiin sekä siihen tiiviisti liittyviin käsitteisiin (mm. call-by-need, call-by-name ja thunk). Lukija saa tästä tarvittavaa sanavarastoa tekstin lukemiseen.

\subsection{Keskeisten käsitteiden määrittely}

\textit{Lauseke} tarkoittaa ohjelmointikielen ilmaisua, jolle voidaan määrittää arvo. Esimerkiksi aritmeettiset operaatiot, muuttujien nimet ja funktiokutsut ovat lausekkeita.

\textit{Evaluointi} tarkoittaa tarkoittaa lausekkeen arvon laskemista.

\textit{Evaluointistrategia} tarkoittaa ohjelmointikielen sääntöjä, jotka määrittävät, missä tilanteissa lausekkeita evaluoidaan.

\textit{Laiska evaluointi} tarkoittaa evaluointistrategiaa, joka viivyttää lausekkeen evaluointia saakka, kunnes sitä tarvitaan \citep{watt2004programming}. Käsitettä voi käyttää kuvaamaan myös yksittäistä lauseketta abstraktimman operaation, kuten esimerkiksi kokoelmien käsittelyn, suorittamisen viivästämistä vastaavaan tapaan.

% 4. Kerron, että olen hakemassa vastausta kahteen tutkimuskysymykseen: mikä sen merkitys tietotekniikassa on nykyhetkellä, ja millaisia vahvuuksia tai heikkouksia laiskalla evaluoinnilla on. Samassa yhteydessä kerron perustellen, että olen tarkoituksella jättänyt laiskan evaluoinnin matemaattisen ja kääntäjäteknisen tarkastelun tämän työn ulkopuolelle. Myös työn muista tavoitteista mainitseminen on mahdollista: voin vaikka mainita siitä, että toivon työn tulosten olevan hyödynnettävissä ohjelmoinnin opetuksessa.

% 5. Kerron käyttämäni tieteelliset menetelmät (kirjallisuuskatsaus ja mielipidekartoitus) ja perustelen miksi päädyin juuri näihin menetelmiin. Valotan kirjallisuuskatsauksen prosessia: mitä hakusanoja käytin, mitä tietokantoja hyödynsin ja millaisia määriä artikkeleita kävin läpi. Käyn samaan tapaan läpi mielipidekartoituksen toteutuksen, eli sekä tunnettujen kirjoittajien blogien läpikäynnin että kokemusten keräämisen tuttavapiiristäni.

\subsection{Tutkimuskysymykset}

Haluan saada kartoitettua työlläni laiskan evaluoinnin käyttökelpoisuutta tutkimuksessa ja työelämässä, ja haluan myös tuottaa sellaista tietoa, joka olisi käyttökelpoista laiskan evaluoinnin konseptien yliopisto-opetuksen suunnittelutyössä. Päädyin näiden tavoitteiden kautta seuraaviin tutkimuskysymyksiin:
\begin{enumerate}
  \item{Mikä on laiskan evaluoinnin merkitys nykypäivänä?}
  \item{Mitkä ovat laiskan evaluoinnin hyödyt ja haitat?}
\end{enumerate}

Kysymyksessä 1 laiskan evaluoinnin merkityksen tutkiminen tarkoittaa, että tarkastelen (a) laiskan evaluoinnin varhaista historiaa pohjustuksenomaisesti, (b) laiskan evaluoinnin leviämistä moderneihin ohjelmointikieliin sekä kielien apukirjastoihin, (c) laiskan evaluoinnin kautta kehittyneitä uusia ohjelmoinnin konsepteja ja (d) laiskaa evaluointia käyttävien teknologioiden hyödyntämistä tutkimuksessa ja työelämässä.

Kysymyksessä 2 selvitän sitä, millaisia subjektiivisia mielipiteitä laiskaa evaluointia hyödyntäviä teknologioita käyttävillä ihmisillä on sekä laiskasta evaluoinnista yleisesti, että kysymyksen 1 tarkastelussa esiin tulleista ohjelmointikielistä ja apukirjastoista.


\subsection{Tutkimusmenetelmät}

Tarkastelen kysymystä 1 narratiivisen kirjallisuuskatsauksella avulla. Tavoitteena on kartoittaa, millaista tietoa aiheesta tällä hetkellä on, ja tuoda sitä yhteen helppotajuisen narratiivin muotoon. Tällä tavoin luotu katsaus soveltuu hyvin materiaaliksi opettajille \citep[s. 312]{baumeister1997writing}, joten menetelmävalinta on linjassa sen tavoitteen kanssa, että työstä olisi hyötyä yliopisto-opetuksen suunnittelussa.

Kirjallisuuskatsauksen materiaalina käytän ensisijaisesti akateemisia artikkeleita, joita aiheesta on kirjoitettu paljon. Hain artikkeleita ensisijaisesti Scopus-tietokannasta, jossa käytin seuraavaa hakulauseketta:

\begin{verbatim}
 ("lazy evaluation" OR "non-strict" OR "call-by-need" OR "call by need")
 AND ("functional")
\end{verbatim}

And-operaattorin vasemmalla puolella on kaikki laiskan evaluoinnin tyypillisimmät synonyymit vaihtoehtoisina hakutermeinä.\footnote{Puhtaan funktionaalisen ohjelmoinnin, erityisesti Haskell-ohjelmointikielen, sanastossa käsitteellä \textit{non-strict} on usein laiskasta evaluoinnista eriävä merkitys. Tätä kasitellään tarkemmin luvussa 2. Kirjallisuudessa käsitteet kuitenkin esiintyvät myös toistensa synonyymeina.} Operaattorin oikealla puolella oleva hakutermi \textit{functional} rajaa hakutulokset funktionaalisen ohjelmoinnin piiriin. Tämä hakulauseke tuotti otsikosta, tiviistelmästä ja avainsanoista haettaessa 326 tulosta. Tämä oli sopiva määrä tuloksia tutkimuskysymysten kannalta relevanteimpien artikkeleiden valikointia ajatellen.

Scopus-tietokannan lisäksi seuloin artikkeleita samalla hakutermillä myös Google Scholarista. Lisäksi Stack Overflow -kysymyspalvelun vastausten ja Haskellin oman wiki-alustan kautta löytyi useita linkkejä relevantteihin artikkeleihin. Täydensin akateemisista artikkeleista saatua tietoa myös vähäisissä määrin blogikirjoituksilla. Niistä on iloa sellaisten uusien kehityskulkujen esittelyssä, joiden esiintyminen akateemisissa artikkeleissa on hyvin vähäistä.

\textit{Pitää vielä selvittää, mitkä tutkimusmenetelmät kuvaisivat parhaiten sitä mielipideselvitystä, joka tehdään tutkimuskysymykseen 2 vastaamiseksi.}
% 6. Esittelen työn rakennetta perustellen sen menetelmien ja tutkimuskysymysten avulla. Kerron, että käsittelen ensin katsausmaisesti laiskan evaluoinnin varhaista historiaa, minkä jälkeen poraudun ensimmäiseen tutkimuskysymykseen laiskasta evaluoinnista nykypäivänä. Sitten, kun lukijalla on hyvä yleiskuva nykypäivän sovellutuksista, on sujuvaa siirtyä puhumaan yksittäisten sovellutusten yksityiskohdista sekä vahvuuksista ja heikkouksista.

Kirjallisuuskatsauksen ja mielipideselvityksen käsittelyjärjestystä tässä työssä esittelee seuraava osio, työn rakenne.

\subsection{Työn rakenne}

\textit{Kirjoitan myöhemmin auki, kun sisällysluettelo hahmottuu:}

Esittelen työn rakennetta perustellen sen menetelmien ja tutkimuskysymysten avulla. Kerron, että käsittelen ensin katsausmaisesti laiskan evaluoinnin varhaista historiaa, minkä jälkeen poraudun ensimmäiseen tutkimuskysymykseen laiskasta evaluoinnista nykypäivänä. Sitten, kun lukijalla on hyvä yleiskuva nykypäivän sovellutuksista, on sujuvaa siirtyä puhumaan yksittäisten sovellutusten yksityiskohdista sekä vahvuuksista ja heikkouksista.

% 7. Nykypäivän tilannetta taustoitan aluksi kertomalla, kuinka idea laiskasta evaluoinnista on saanut alkunsa akateemisena ideana, jota alettiin kokeilla erilaisissa ohjelmointikielissä, ja jopa prosessoriarkkitehtuureissa. Tästä siirryn Haskellin kehitykseen, ja siihen, kuinka laiskan evaluoinnin vaatimus osaltaan johti puhtaasti funktionaalisen ohjelmoinnin paradigman kehittymiseen.  Käsittelyssä tässä kappaleessa siis käytännössä noin vuodet 1975-2000. Tässä elävöitän tekstiä historia-anekdooteilla.

\section{Laiskan evaluoinnin historiaa}

Laiska evaluointi sai alkusysäyksensä 1970-luvulla. Sarja julkaisuja loi pohjaa ajatukselle laiskoista funktionaalisista kielistä työkaluna käytännönläheiseen ohjelmistokehitykseen. Ajatus esiteltiin ensimmäisenä matemaattisesti lamdakalkyylin, funktionaalisen ohjelmoinnin kannalta keskeisen matemaattisen teorian, näkökulmasta \citep{wadsworth1971semantics}. Viisi vuotta myöhemmin julkaistiin toisistaan riippumatta kolme artikkelia \citep{henderson1976lazy,friedman1976cuns,saslmanualturner}, joissa esiteltiin laiskaa evaluointia ohjelmoinnin perspektiivistä.

1980-luvulla vaihteessa oli uraauurtavaa kehitystä kohti ensimmäisiä laiskoja ohjelmointikieliä. Saman aikaan kehitettiin myös täysin uudenlaisia tietokoneita, jotka kilpailivat alan standardin, Von Neumannin arkkitehtuurin, kanssa. Kuitenkin pidemmän päälle osoittautui, ettei tarvetta erikoisille arkkitehtuureille ole, vaan hyvin laadituilla ohjelmointikielten kääntäjillä voidaan päästä hyviin lopputuloksiin myös Von Neuman -arkkitehtuuria hyödyntävissä tietokoneissa. \citep{hudak2007history}

\subsection{Ei-tiukka semantiikka ja graafireduktio}

Yhdistävää 1980-luvun vaihteessa kehitetyille laiskoille ohjelmointikielille oli, että niissä alettiin hyödyntämään sittemmin vakiintuneita \textit{ei-tiukan semantiikan} ja \textit{graafireduktion} periaatteita. Jos ohjelmointikieli perustuu ei-tiukalle semantiikalle, niin lausekkeella voi olla arvo, vaikka jollakin sen alilausekkeista (pienemmistä lausekkeista, joista lauseke koostuu) ei olisi arvoa. Vastaavasti \textit{tiukkaan semantiikkaan} perustuvat ohjelmointikielet toimivat siten, että jos joltakin alilausekkeelta puuttuu arvo, niin lausekkellakaan ei ole arvoa, ja tällöin lausekkeen evaluoinnin voi ajatella epäonnistuneen \citep[s. 523]{scott2009programming}.

Tiukkaa semantiikkaa käytetään yleisesti imperatiivisissa ohjelmointikielissä. Useimmissa suosituissa imperatiivisissa kielissä, esimerkiksi Pythonissa, tiukan semantiikan toteutus perustuu funktioiden evaluointijärjestykseen liittyviin sääntöihin. Evaluointi etenee ``sisimmät ensin'' -periaattella. Siinä funktion kaikki argumentit evaluoidaan ennen kuin funktiota kutsutaan, ja evaluointi etenee sisimmästä funktiokutsusta ulompia funktiokutsuja kohti.

Vastaavasti ei-tiukan semantiikan tyypillisin toteutus, jota tapaa esimerkiksi Haskellissa, perustuu ``uloimmat ensin'' -periaatteeseen. Siinä funktioiden evaluointi etenee uloimmasta funktiokutsusta kohti sisempiä, ja ainoastaan ne funktion argumentit, joita funktio todellisuudessa käyttää, evaluoidaan. Siten Haskellissa on mahdollista tehdä jopa sellaisia funktioita, joka ei tarvitse argumentteja lainkaan, ja siten palauttaa arvon riippumatta siitä, onko parametrilausekkeilla arvoa vai ei. \citep{haskellwikinonstrict}.

Taulukko \ref{table:python_haskell_semantics} demonstroi semantiikan vaikutusta funktioiden evaluointiin. Siinä on toiminallisuudeltaan vastaava koodi suoritetaan sekä Pythonilla että Haskellilla. Funktio \verb!noreturn! aiheuttaa ikuisen silmukan, minkä tähden se ei koskaan palauta arvoa. Haskellilla lausekkeen evaluointi palauttaa arvon, koska \verb!noreturn! -funktiota ei koskaan kutsuta.

\makeatletter
\preto{\@verbatim}{\topsep=0pt \partopsep=0pt }
\makeatother
\newpage
\begin{table}[th]
  \begin{center}
    \begin{tabular}{|p{0.5\textwidth}|p{0.40\textwidth}|}
      \hline
       Python, tiukka semantiikka& Haskell, ei-tiukka semantiikka \\
      \hline
      \footnotesize

      \begin{alltt}
def noreturn(x):
    while True:
        x = -x
    return x # not reached

def even(x):
  return x % 2 == 0

> any(even(n) for n in [3, 2, noreturn(6)])
\(\Rightarrow\) (ei palauta arvoa)
    \end{alltt}
      &\footnotesize\begin{alltt}
noreturn :: Integer -> Integer
noreturn x = negate (noreturn x)

> any . even . [3, 2, noreturn 6]
\(\Rightarrow\) True

\end{alltt}

      \textit{Katsotaan, haluanko tässä vielä käydä evaluoinnin välivaiheita läpi, vai viittaanko samaan esimerkkiin myöhemmin uudelleen.}\\
      \hline
    \end{tabular}
    \caption{Esimerkki kielen semantiikan vaikututuksesta evaluointijärjestykseen }
    \label{table:python_haskell_semantics}
  \end{center}
\end{table}

Graafireduktio on tapa ei-tiukan semantiikan toteuttamiseen. Se esittää lausekkeet verkon muodossa, mikä mahdollistaa toistuvien lausekkeiden jakamisen muiden lausekkeiden kesken \citep{hudak1989conception}. Esimerkiksi lausekkeen \verb!(1+2)*(1+2)! verkkoesityksessä lauseke \verb!(1+2)! pystytään jakamaan, minkä myötä sen arvo tarvitsee evaluoida vain kerran. % LÄHDE?

Ei-tiukan semantiikan ``uloimmat ensin'' -suoritusjärjestys ja graafireduktiossa tapahtuva lausekkeiden jakaminen luovat perustan laiskalle evaluoinnille. Lausekkeen arvoa ei lasketa ennen kuin on tarve, eikä sitä turhaan lasketa uudelleen, jos sitä käytetään myöhemmin uudelleen.

\subsection{Haskellin ja puhtaan funktionaalisen ohjelmoinnin kehitys}

\citet{hudak2007history} kuvaa, kuinka 1980-luvun puolivälissä laiskaa evaluointia hyödyntäviä ohjelmointikieliä alkoi olla ruuhkaksi asti. Useimmat kielistä soveltuivat vain kapeaan määrään käyttökohteita, ja niillä ei ollut riittävää määrää käyttäjiä suuren suosion saavuttamiseksi. Kuitenkin artikkelin kirjoittajat olivat tällöin sitä mieltä, että kielet muistuttivat ominaisuuksiltaan hyvin paljon toisiaan. Alkoi kehittyä ajatus siitä, että olisi hyvä luoda yksi, yleinen kieli, joka korvaisi kerralla monia aikaisempia kieliä.

Tämä johti Haskell-ohjelmointikielen kehityksen aloittamiseen. Siitä vastasi Haskell-komitea, jossa vaikutti monia aikaisempien laiskaa evaluointia hyödyntäneiden kielien suunnittelijoita. Komitea onnistui keräämään yhteen aikaisemmin erillään samaa aihepiiriä tutkineita, mikä kiihdytti laiskan evaluoinnin parissa tapahtunutta tieteellistä kehitystä. Alkuvaiheen kehitystyö oli onnistunutta, ja Haskellista kehittyi etenkin tietojenkäsittelytieteen akateemisen tutkimuksen parissa suosittu kieli.

Haskell ei määritelmällisesti ole laiska ohjelmointikieli, vaan jo Haskell 1.1 -raportissa \citep{yale1991report} se määriteltiin ainoastaan ei-tiukkaa semantiikkaa käyttäväksi kieleksi. Käytännössäkään kieli ei ole täysin laiska, vaan Haskellin kääntäjät tekevät useita nopeusoptimointeja suorittamalla tiettyjä osia koodista tiukkaan semantiikan säännöllä. Useimmat kielen rakenteet noudattavat kuitenkin oletusarvoisesti laiskan evaluoinnin periaatteita.

Laiskassa evaluoinnissa koodia ei suoriteta imperatiivisten kielien tapaan rivi riviltä, vaan suoritusjärjestys määräytyy tarpeen mukaan. IO-operaatioita, eli esimerkiksi näytölle tulostamista tai käyttäjän syötteen odottamista, ei pystytä suorittamaan halutussa järjestyksessä pelkkien funktiokutsujen avulla. Tästä seurasi, että Haskellista tuli \textit{puhtaasti funktionaalinen} ohjelmointikieli. Käsitteellä tarkoitetaan, että kielen funktiokonstruktiot ovat funktioita matemaattisessa mielessä: funktion kutsuminen samoilla argumenteilla palauttaa aina saman arvon, eikä funktioilla voi suorittaa IO-operaatioita tai muita ohjelman tilaa muuttavia operaatioita.

% Jotain mainintaa pysyvätilaisista muuttujista?

Laiskan evaluoinnin periaatteiden noudattaminen on johtanut moniin innovaatioihin funktionaalisen ohjelmoinnin saralla. Koska Haskell on puhtaasti funktionaalinen kieli, täytyi kehittää kokonaan uusia konsepteja, jotta esimerkiksi IO-operaatioiden suorittaminen halutussa järjestyksessä ja niiden ketjuttaminen toisiinsa onnistuu. Tunnetuimmaksi konseptiksi on noussut \textit{monadi}. Alkuperäisessä monadin konseptin esitelleessä artikkelissa sitä kutsutaan ``imperatiivisen funktionaalisen ohjelmoinnin'' työkaluksi, mikä kuvaa monadien mahdollistamia sekventiaalisia IO-operaatioita \citep{PeytonJones199371}.

Niin monadi kuin monet muutkin Haskelliin kehitetyt puhtaan funktionaalisen ohjelmoinnin konseptit ovat levinneet myös sellaisiin ohjelmointikieliin, jotka ovat evaluointistrategialtaan tiukkoja. Siten laiskan evaluoinnin vaalimisen Haskellissa voi ajatella olleen hyödyksi tietojenkäsittelytieteen kehitykselle laajemminkin.

\subsection{Päättymättömät tietorakenteet ja kontrollirakenteet}

Jo 1980-luvun varhaisessa tutkimuksessa käsiteltiin laiskan evaluoinnin mahdollistamia laiskoja tietorakenteita, etenkin ``päättymättömiä tietorakenteita''. Näitä ovat muun muassa päättymättömät listat, puurakenteet ja tapahtumavirrat. Ne ovat tyypillisesti rekursion avulla toteutettuja, ja laiskan evaluoinnin ansiosta tietorakenteessa tarvitsee mennä vain niin ``syvälle'' kuin on tarvetta.

\newpage

Eräs klassinen esimerkki on matematiikan äärettömiä lukujonojen kuvaaminen. Seuraavassa on Fibonaccin lukujono ilmaistuna rekursiivisesti Haskellilla. Huomionarvoista on, kuinka paljon koodi muistuttaa tapaa, jolla rekursiivinen lukujono ilmaistaisiin matematiikassa:

\begin{alltt}
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
\end{alltt}

Laiska evaluointi mahdollistaa myös omien kontrollirakenteiden kirjoittamisen. Esimerkiksi if-ehtolauseesta on Haskellissa helppoa tehdä oma versio, jossa ehdon täyttymisen perusteella evaluoidaan vain jompikumpi vaihtoehtoisista lausekkeista:

\begin{alltt}
% Käyttö: myIf condition onTrue onFalse
myIf :: Bool -> a -> a -> a
myIf True  x _ = x
myIf False _ y = y
\end{alltt}

% Tässä olisi ehkä kiva mainita toki siitä, että täsmäkielen rakentamiseen vaikuttaa toki monta muutakin tekijää.
Omien kontrollirakenteiden tuki helpottaa kieleen upotettujen \textit{täsmäkielten} rakentamista. Täsmäkielillä tarkoitetaan pieniä, tavanomaisesti deklaratiivisia kieliä, jotka ovat hyvin ilmaisuvoimaisia tietyssä ongelma-avaruudessa \citep{van2000domain}. Täsmäkielet toteutetaan usein ohjelmointikielen apukirjastoina, ja täsmäkieli on siinä tapauksessa yhdistelmä ohjelmointikielen valmiita ominaisuuksia ja apukirjastossa siihen laadittuja lisäyksiä.

Seuraavassa luvussa siirrytään tarkastelemaan sitä, millaisia sovellutuksia laiskalle evaluoinnille on löydetty erilaisissa ohjelmointikielissä ja ohjelmointiin liittyvissä \mbox{konteksteissa.}

% 8. Käyn läpi sitä, kuinka Haskell ja laiska evaluointi alkoi inspiroimaan monia uusia ohjelmointikieliä ja ohjelmointikielien kirjastoja. Tässä kohtaa keskityn nimenomaan siihen diversiteettiin, eli millaisissa erilaisissa muodoissa laiska evaluointi nykyään esiintyy, ja kuinka sitä käytetään myös tiukan evaluoinnin rinnalla. Käyn läpi paljon esimerkkejä laiskan evaluoinnin sovellutuksista. Jos esimerkkien määrä on suuri, se voi aiheuttaa haasteita luvun jäsentämiselle.

\section{Laiskan evaluoinnin sovellutuksia}


Laiskalle evaluoinnille on löydetty lukuisia erilaisia sovellutuksia. Tähän lukuun on koottu niistä merkittävimpiä. \textit{Kirjoitetaan tämä pohjustusteksti uudelleen, kun sisältö on selkeytynyt.}

\subsection{Tuki Scala-ohjelmointikielessä}

\textit{Scala} on sekä funktionaalista että imperatiivista ohjelmointia tukeva yleiskäyttöinen ohjelmointikieli. Scala-lähdekoodi kääntyy Java-tavukoodiksi, ja kieli on täysin yhteensopiva Java-kirjastojen kanssa. Scala on semantiikaltaan tiukka kieli, mutta evaluointijärjestystä on mahdollista muuttaa paikallisesti kahdella mekanismilla: \textit{laiskoilla muuttujilla} ja \textit{by-name-parametreilla}.

Laiska muuttuja luodaan lisäämällä \verb!lazy! -avainsana muuttujan määrittelyn alkuun. Kyseisen muuttujan arvon määrittävä lauseke evaluoidaan vasta sitten, kun muuttujaa käytetään ensimmäistä keraa. Arvo myös sidotaan muuttujaan, eli jos muuttujaa tarvitaan uudelleen, niin arvoa ei tarvitse evaluoida uudelleen.

By-name-parametri on funktion parametri, joka luodaan funktion määrittelyssä syntaksilla \verb!parameterName: => Type!. Funktiokutsussa parametrin arvo evaluoidaan vasta, kun parametria käytetään. Laiskasta muuttujasta poiketen arvoa ei kuitenkaan evaluointihetkellä sidota parametriin, vaan jos parametria käytetään uudelleen, niin arvokin evaluoidaan uudelleen.

Laiskojen muuttujien ja by-name-parametrien avulla Scalassa pystyy toteuttamaan monia laiskalle evaluoinnille ja puhtaalle funktionaaliselle ohjelmoinnille tyypillisiä piirteitä, kuten omia kontrollirakenteita ja laiskoja listoja \citet{chiusano2014functional}. Siten Scalaa pidetään myös tehokkaana kielenä täsmäkielien toteuttamiseen.

\textit{Jotain vielä generaattoreista ja iteraattoreista?}

\subsection{Tuki Clojure-ohjelmointikielessä}

Clojure on funktionaalinen, Lisp-kieleä muistuttava yleiskäyttöinen ohjelmointikieli, joka Scalan tapaan kääntyy Java-tavukoodiksi ja on täysin yhteensopiva Java-kirjastojen kanssa. Clojure on semantiikaltaan tiukka kieli, eikä se tue Scalan tapaan yleistetysti laiskoja muuttujia ja parametreja. Kieli kuitenkin tukee laiskoja listoja, joita varten kielessä on valmis tuki \verb!lazy-seq! -makron avulla.

Käytännössä Clojuren käyttäjä tulee käyttäneeksi laiskoja listoja paljon, sillä monet kielen yleisimmistä listaoperaatioista palauttavat laiskan listan. Näitä operaatioita ovat esimerkiksi \verb!map!, \verb!filter! ja \verb!take!. Clojuren laiskojen listojen arvoja evaluoidaan sitä mukaan kuin niitä tarvitaan, ja arvot pysyvät muistissa tulevia käyttökertoja varten.

Clojure tukee \textit{makroja}, joiden avulla kielen kääntäjää pystyy laajentamaan ohjelmakoodista käsin, ja sen myötä kieleen voi luoda omia kontrollirakenteita. Tämän myötä Clojure ei tarvitse laiskaa evaluointia ollakseen silti tehokas kieli täsmäkielien luomiseen.

\subsection{Käyttö JavaScript-apukirjastoissa}

JavaScript on ainoa verkkoselainten yleisesti tukema ohjelmointikieli, ja lisäksi JavaScriptiä käytetään runsaasti myös palvelinohjelmointiin. Se on semantiikaltaan tiukka kieli, ja tukee rajoitetusti funktionaalisen ohjelmoinnin konsepteja.  JavaScriptiin on 2010-luvulla kehitetty useita apukirjastoja, jotka tuovat funktionaalisen ohjelmoinnin työkaluvalikoimaa laajemmin ohjelmoijien käyttöön. Näistä uusimmissa näkyy kasvavissa määrin laiskan evaluoinnin konseptien vaikutus kirjastosuunnitteluun.

\textit{Immutable.js} on Facebookin julkaisema JavaScript-apukirjasto, joka tarjoaa tuen funktionaaliselle ohjelmoinnille ominaisille pysyvätilaisille tietorakenteille. Kaikki kirjastossa määritellyt tietorakenteet, esimerkiksi indeksoidun listan \verb!List! tai pinon \verb!Stack!, voi muuttaa laiskaksi \verb!Seq!-konstruktorilla. Listaoperaatiot ovat tämän luokan metodeja, ja kun \verb!Seq!-instanssille kutsuu näitä metodeja, ne palauttavat uuden laiskan listan.
Ketjutetut listaoperaatiot evaluoidaan vasta sitten, kun lopullista arvoa tarvitaan.

\begin{sloppypar}
\verb!Seq! tukee myös päättymättömiä listoja kirjaston tarjoamien \verb!Range!- ja \verb!Repeat! \mbox{-konstruktoreiden} sekä iteraattorifunktioiden avulla. \verb!Seq! ei kuitenkaan Clojuren laiskojen listojen tapaan pidä evaluoituja arvoja muistissa.
\end{sloppypar}

\textit{Lazy.js} on JavaScriptin-apukirjasto listamaisten tietorakenteiden käsittelemiseen. Siinä Immutablen laiskaa listan luontia vastaa konstruktori \verb!Sequence!. Lazy.js ei Immutablen tapaan esittele uusia tietorakenteita, vaan sitä voi käyttää yhdessä JavaScriptin sisäänrakennettujen tietorakenteiden kanssa. Toisin kuin Immutable.js, se myös tukee joitain funktionaalisen reaktiivisen ohjelmoinnin konsepteja, joita käsittelen seuraavassa luvussa.

Sekä Immutable.js että Lazy.js lupaavat, että viivyttämällä listaoperaatioiden evaluointia ne ovat merkittävästi nopeampia kuin kilpailijansa, joissa tyypillisesti listan arvo evaluoidaan uudelleen jokaisen listaoperaation kutsun yhteydessä.

\textit{Halutaanko sekä Clojure-osioon että tähän lähdeviittaukset kielen/kirjastojen dokumentaatioihin?}

\subsection{Käyttö reaktiivisessa ohjelmoinnissa}

\textit{Funktionaalinen reaktiivinen ohjelmointi}, lyhyemmin FRP, on deklaratiivinen ohjelmointiparadigma, jolla voi käsitellä muuttuvatilaisia arvoja funktionaalisessa ohjelmoinnissa. FRP esittää muuttuvatilaisen arvon aikariippuvaisena ``signaalina'' . Näitä signaaleja voi transformoida ja yhdistellä joustavasti \citep{czaplicki2012elm}.

Paradigma sai alkunsa Haskellin tutkimuksesta, kun \citet{elliott1997functional} julkaisivat kokeellisen täsmäkielen nimeltä \textit{Fran} animaation kuvaamiseen funktionaalisessa ohjelmoinnissa. Fran pyrki pääsemään irti grafiikkaohjelmoinnin perinteisestä  imperatiivisesta ja diskreetistä luonteesta, ja korvasti sen jatkuvaan aikatarkasteluun perustuvalla mallilla. Fran rakennettiin Haskellilla, ja siten siinä käytettiin laiskaa evaluointia laajasti.

\textit{Reaktiivinen ohjelmointi} tarkoittaa laajemmin ohjelmointiparadigmaa, joka keskittyy datavirtojen ja niiden muutosten käsittelyyn. FRP on inspiroinut monia 2010-luvun suosittuja reaktiivisia kirjastoja, kuten \textit{React}, \textit{RxJS} ja \textit{Bacon.JS}, ja näiden lisäksi myös uusia ohjelmointikieliä on luotu reaktiivisten periaatteiden pohjalta, kuten Elm. Nämä perustuvat diskreettien datavirtojen käsittelyyn, minkä takia ne eivät sovi yhteen FRP:n alkuperäisen määritelmän kanssa \citep{whyprogramwithconttime}.

Valtaosa suosituista kirjastoista ei hyödynnä laiskaa evaluointia.

\subsection{Muut}

\subsection{Apukirjastot}
\begin{itemize}
  \item{Laiska JavaScript-ohjelmointi, Lazy.js jne}
  \item{FRP, Bacon.js, Elm \citep{czaplicki2012elm}}
\end{itemize}
\subsection{Muut}
\begin{itemize}
  \item{Concurrency hässäkät, parallelism?}
  \item{Piirisuunnittelu \citep{charlton1991lazy}}
  \item{Persistentit ohjelmointikielet (aika UG aihe) \citep{wevers2014persistent}}
  \item{Logiikkapohjainen ohjelmointi (jälleen aika UG aihe) \citep{alpuente1997specialization}}
\end{itemize}

% Non-deterministinen ohjelmointi

% "Beyond lazy evaluation": optimistinen evaluointi, lempeä evaluointi

% 9. Nyt valitsen kiinnostavimmat aihealueet/sovellutukset tarkempaan tarkasteluun, ja otan tässä kohtaa myös vahvuus/heikkous -selvityksen mukaan. Perustelen, että laiskaa evaluointia ei ole mieltä tutkia yhtenä kokonaisuutena mielipidearvioinnin keinoin, vaan on järkevämpää keskittyä yksittäisiin sovellutuksiin. Aiheita/sovellutuksia voisi olla esimerkiksi Haskell, Scala, JavaScript-kirjastot ja FRP. Tässä voi saada aikaan mielenkiintoista mielipiteiden, blogien ja tieteellisten artikkeleiden "vuoropuhelua".

\section{Laiskan evaluoinnin edut ja haitat}

\subsection{Yleisellä tasolla}


\subsection{Reaktiivisessa ohjelmoinnissa}
%   \item{Lazy I/O \citep[s.123]{o2008real}}

% 10. Mielipiteistä ja sovellutuksista voisi jatkaa vielä kertomalla laiskan evaluoinnin hyödyntämisestä tieteellisessä tutkimuksessa, kuten laskennallisessa biologiassa. Myös yritysesimerkkejä voi ottaa mukaan. Tämä olisi teoriassa yhdistettävissä edelliseen lukuun, mutta toisaalta koen tämän olevan kuitenkin korkeammalla tasolla (kielten ja kirjastojen vahvuudet/heikkoudet vs. laiskan evaluoinnin soveltuvuus yleisemmin eri alojen työhön).

\section{Laiskan evaluoinnin yleisyys tutkimuksessa ja työelämässä}

% 11. Tarinan kaaren kannalta olisi kandin loppupuolella kiva olla tulevaisuuden tarkastelua. Tässä voisin nostaa vielä pari aikaisemmin raportissa käsiteltyä trendiä, jotka vaikuttavat lupaavilta tulevaisuuden osalta, erikseen tarkasteluun. Voin myös koota yhteen, millaisten esteiden raivaaminen voisi auttaa laiskaa evaluointia entistä suurempaan suosioon.

% 12. Yhteenvedon yhteydessä arvioidaan vielä työn metodisia heikkouksia/rajoituksia, ja mitä puutteita niistä on mahdollisesti seurannut. Sitä, mitä muuta yhteenvedossa olisi mielekästä käsitellä, pitää vielä selvittää.

\section{Yhteenveto ja johtopäätökset}

Laiskasta evaluoinnista on kehitetty edelleen uusia evaluointistrategioita. Optimistinen evaluointi, lempeä evaluointi. \citep{ennals2003optimistic} \citep{maessen2002hybrid}

% \subsection{Yhteenveto}
% Työssä jäi vähäiseksi algoritminen ja matemaattinen näkökulma. Miksi se olisi ollut hyödyllistä?
