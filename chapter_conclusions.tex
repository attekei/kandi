% DONE (maybe still check the supervisor comments for one more time)
% -------------------------------------------------------------------
% Cheatsheet:
% \verb!lazy val!   -- esim. lyhyisiin koodinpätkiin
% \begin{verbatim}  -- esim. pitkiin koodinpätkiin
% `` tekstiä ''     -- lainausmerkit
% \textbf{huom!}    -- boldaus
% \begin{quotation}
% \noindent \it     -- quoten lisäys
% \ldots            -- kolme pistettä
% footnote{juh}     -- alaviite
% \citet, \citep
% \citet[s.234]{}   -- viitteet, http://merkel.zoneo.net/Latex/natbib.php
% \begin{sloppypar} -- ahdas teksti
% \clearpage        -- onkkelmien korjaamiseen lukujen kanssa
% --                -- yhdysviiva
% \enumerate
% \itemize          -- listat
% \begin[htb]{figure}
% \begin[htb]{table} - Kuva ja taulukko, (h)ere, (t)op, (b)ottom
% \begin{equation}  -- kaava
% \label{eq:kaava1} -- laabeli
%!TEX root = main.tex

\section{Yhteenveto ja johtopäätökset}\label{yhteenveto}

Aloitan käymällä läpi, millaisia vastauksia sain tutkimuskysymyksiini.

Käsitteitä määritellessä selvisi, että laiskaan evaluointiin liittyen käytetään paljon päällekkäistä käsitteistöä, mikä hankaloittaa aiheeseen tutustumista. Tässä työssä päädyin käyttämään paljon normaalijärjestyksessä evaluoinnin ja sen vastakohdan applikatiivisen evaluoinnin käsitteitä, koska ne ovat yksiselitteisesti määriteltyjä. Laiska evaluointi ja ahne evaluointi osoittautuivat yleiskäsitteiksi, joilla voidaan kuvata useita eri evaluointistrategioita.

Tietojenkäsittelytieteessä normaalijärjestyksessä evaluointi on selkeästi ollut keskeistä etenkin funktionaalisen ohjelmoinnin kehityksen kannalta. Se on kannustanut rakentamaan kieliä, jossa muuttujien arvot pysyvät vakiona ja funktiot käyttäytyvät ennakoitavaksi, koska tällöin komentojen suoritusjärjestystä voi muuttaa ja suoritusta voi viivästää.

Normaalijärjestyksessä evaluointia osataan käyttää yhä kypsemmin ja kypsemmin: sen ja applikatiivisen evaluoinnin välillä osataan tasapainotella, ja laiskaa evaluointia käytetään rajatummin kuin aikaisemmin. Tämä liittyy siihen, että laiskan evaluoinnin laajamittainen käyttö aiheuttaa ongelmia sekä nopeuden että muistinkäytön ennustettavuuden suhteen. Rajatuissa sovellutuksissa näitä ongelmia ei pääse syntymään.

Vaikuttaa myös siltä, että normaalijärjestyksessä evaluointi itsessään ei merkittävästi helpota ohjelmointiongelmien kuvaamista ja ratkaisemista. Oikeastaan laajamittainen käyttö vaikeuttaa muistivuotojen identifioimista sekä suorituksen seuraamista. Nykyiset työkalut esimerkiksi Haskellin suorituksen seuraamiseen ovat hyvin puutteelliset verrattuna moniin applikatiivisesti evaluoituihin kieliin.

\subsection{Metodologisia puutteita}

Mielipidetutkimuksen otos oli pieni ja tutkimusmenetelmä hieman epämääräinen. Oli kätevää kysyä kokemuksia työkavereilta firman viestintätyökalun käyttää, mutta keskustelu ei ollut luonteeltaan kovin jäsentynyttä. Kirjallisuudessakin mielipiteitä ja kokemuksia oli hajanaisesti eri aiheista. Oli vaikeaa luoda yksittäiseen ala-aiheeseen, kuten laiskan evaluoinnin nopeushyötyihin ja -haittoihin, monipuolista näkemystä.

\subsection{Alan ongelmia}

Toivoisin, että etenkin Haskell-yhteisö kävisi vastaisuudessa enemmän keskustelua siitä, millaista käsitteistöä he käyttävät evaluointisemantiikkoihin liittyen. Haskell-wiki, joka on monelle Haskellin käyttäjälle tärkeä oppimateriaali, ei käytä lainkaan alan vakiintuneita call-by-value ja call-by-need -käsitteitä, vaikka ne ovat kuvaavia ja selkeästi määriteltyjä termejä. Sen sijaan Haskell-yhteisö puhuu paljon ei-tiukasta semantiikasta, joka ei ota ohjelmakoodin evaluoinnin etenemiseen suoraan kantaa. Minulle tuli Haskell-wikiä lukiessa usein sellainen olo, että asioita ei selitetä siinä riittävän selkeästi.

Haskell-wikin toinen ongelma on, että siinä laiskan evaluoinnin aiheuttamia ongelmia ei käsitellä riittävästi. Päinvastoin laiskaa evaluointia ja ei-tiukkaa semantiikkaa ylistetään varsin kritiikittömästi. Tämä johtaa monia Haskelliin tutustuvia harhaan, ja voi johtaa siihen, että Haskellin käytön aloittaneet kohtaavat isoja ongelmia kieltä käyttäessään.

\subsection{Tulevaisuudennäkymiä}

Yhtenä uutena kiinnostavana trendinä on totaalisesti funktionaalinen ohjelmointi, jossa funktiot ovat täydellisesti määriteltyjä, eli ne saavat poikkeuksetta arvon \citep{turner2004total}. Päättymättömiä silmukoita tai loputtomia rekursioita ei siis näissä kielissä esiinny.

Näiden kielien kannalta sillä, onko kieli applikatiivisesti vai normaalijärjestyksessä evaluoituva, ei ole merkitystä. Idris-niminen kieli, joka on viimeisenä muutamana vuotena saavuttanut suosiota, on valinnut applikatiivisen evaluoinnin. Kielen luojien perusteena valinnassa on, että applikatiivisesti evaluoidut ohjelmat ovat ennakoitavampia suorituskyvyltään \citep{idrisfaqwhynotlazy}.

\subsection{Mahdollisia tutkimuskysymyksiä}
Olisi kiinnostavaa tutkia, miten työssä esiteltyjä laiskan evaluoinnin sovellutuksia voisi toteuttaa sellaisiin ohjelmointikieliin, jossa niitä ei vielä ole. Näitä kieliä voisivat olla esimerkiksi Java ja Go.

Olisi myös hyödyllistä saada selville, miten applikatiivista evaluointia käyttävissä kielissä nopeuteen ja muistinkäyttöön liittyvistä ongelmista voisi päästä eroon. Mikä olisi esimerkiksi paras tapa varoittaa käyttäjää, että hänen kirjoittamansa ohjelmakoodi saattaa aiheuttaa muistinkäytöllisiä ongelmia? Voisiko myös kehittää parempia ohjelmien suorituksen tarkkailemiseen tarkoitettuja työkaluja, jotka toisivat nämä ongelmat havainnollisesti ilmi?

\subsection{Oma oppimiseni}

Koin kandityön tekemisen itselleni hyödylliseksi. Tutustuin evaluointisemantiikkoihin ja funktionaaliseen ohjelmointiin paljon syvemmällä tasolla kuin aikaisemmin. Pystyn nyt tekemään valistuneempia valintoja siitä, millainen ohjelmointikieli soveltuu parhaiten käsillä olevaan ongelmaan, ja kykenen hyödyntämään laiskaa evaluointia rajatuiden ongelmien ratkaisemisessa.

Oli silmiä avaavaa huomata, kuinka epäselvää tietojenkäsittelytieteiden käsitteistö usein on. Koen, että jatkossa minun on tärkeää kiinnittää enemmän huomiota siihen, että kommunikoin yksiselitteisiä käsitteitä käyttäen työssäni, jotta saan vältettyä epäselvyyksiä.